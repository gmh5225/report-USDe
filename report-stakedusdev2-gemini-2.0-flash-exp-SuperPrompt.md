# Generated by [Mush Audit](https://mush-audit.vercel.app/)

## About

The `StakedUSDeV2` contract is a staking contract that allows users to stake USDe tokens and earn a portion of protocol yield. It inherits from `StakedUSDe`, which implements basic staking functionality based on the ERC4626 standard and includes a single admin access control. `StakedUSDeV2` introduces a cooldown period for unstaking, which allows the contract to manage yield distribution before users can fully withdraw their staked USDe. It also has a `USDeSilo` contract to store USDe during the cooldown period. The contract defines roles for rewarders, blacklist managers, soft-restricted stakers, and full-restricted stakers, with appropriate access controls. It also handles token rescue and redistribution of locked funds.

## Findings Severity breakdown
- Critical: 0
- High: 2
- Medium: 2
- Low: 5
- Gas: 2

### Unprotected `setCooldownDuration` function leading to possible DoS or broken ERC4626 compliance.
- **Title:** Unprotected `setCooldownDuration` Function
- **Severity:** High
- **Description:** The `setCooldownDuration` function is only protected by `onlyRole(DEFAULT_ADMIN_ROLE)`, which can be managed by a single admin account. This function allows the admin to set an arbitrary `cooldownDuration` value, up to `MAX_COOLDOWN_DURATION`. If set to zero, `StakedUSDeV2` returns to ERC4626 standard behavior, and when greater than zero it breaks it. Although this is intended functionality, it poses a risk, because malicious admin can switch on and off this feature at any time, which leads to broken ERC4626 compliance and possible denial of service attacks.
- **Impact:** A malicious or compromised admin could set the `cooldownDuration` to an extremely high value, effectively locking user funds and preventing them from withdrawing their assets. Furthermore, constantly switching on and off the cooldown breaks the ERC4626 compliance.
- **Location:** StakedUSDeV2.sol:138
- **Recommendation:**  Consider implementing a timelock mechanism for changing the cooldown duration, especially if the contract is to be fully compliant with ERC4626 when no cooldown is set. This will reduce the power of a single admin, and provide users a window to exit if the cooldown is set maliciously. Also, consider adding an additional function that clearly disables the cooldown and sets the functionality to full ERC4626.

---
### `redistributeLockedAmount` function potentially leading to loss of funds
- **Title:** `redistributeLockedAmount` Function Logic Error
- **Severity:** High
- **Description:** The `redistributeLockedAmount` function, designed to transfer assets away from a fully restricted user to another address or to a vesting amount, lacks proper validation and potentially leads to a loss of funds. The function checks `hasRole(FULL_RESTRICTED_STAKER_ROLE, from)` but then uses `balanceOf(from)` to calculate the amount to transfer. A malicious user can manipulate `balanceOf` via different mechanisms, such as directly transferring tokens to this contract, bypassing the burning mechanism of the current implementation, and not adding to the `vestingAmount`. It is also very unclear what is the intended logic if `to == address(0)`. Currently if the `to` address is address(0), the amount is just added to the vesting amount and not burned which is against current comments and expected behavior.
- **Impact:** A malicious actor or compromised owner could exploit this function to burn tokens and not adding them to the vesting amount, creating a discrepancy between user balances and actual assets or steal user funds.
- **Location:** StakedUSDe.sol:165
- **Recommendation:**  The `redistributeLockedAmount` function should accurately reflect what it is intended to do, and avoid token manipulation by the malicious user. The burn function should burn the amount with the `from` address. The function must not mint tokens if the `to` address is the zero address. The intended functionality should also be more clear in comments.

---

### Insufficient check in `_updateVestingAmount` function
- **Title:** Insufficient Vesting Check
- **Severity:** Medium
- **Description:** The `_updateVestingAmount` function reverts if `getUnvestedAmount() > 0`, meaning that new rewards cannot be transferred while there is still vesting period pending from previous reward distribution. This leads to a situation when no rewards can be distributed if any small amount remains vested.
- **Impact:** The protocol could halt reward distribution for the whole vesting period if any small amount remains to be claimed.
- **Location:** StakedUSDe.sol:313
- **Recommendation:** Consider allowing reward distribution even if a small vest amount remains. Consider changing this logic. There could be a better way to handle vesting if the logic of `_updateVestingAmount` is changed.

---
###  Unclear functionality of `renounceRole` function
- **Title:**  Inconsistent `renounceRole` Function Behavior
- **Severity:** Medium
- **Description:** The `renounceRole` function is overridden in `StakedUSDe` to always revert with `OperationNotAllowed()`, effectively disabling role renunciation for all roles, including non-admin roles. This contradicts the implementation in `SingleAdminAccessControl`, where `renounceRole` is intended to allow users to relinquish their roles. The comments in `StakedUSDe` indicate that this prevents users from resigning, but it blocks the functionality for all roles.
- **Impact:** It might break the expected behavior and reduce composability and flexibility of the contract in future implementation. The user will never be able to renounce any role.
- **Location:** StakedUSDe.sol:345
- **Recommendation:** Review the design choice and decide whether it is intended behavior. Consider removing the overriding implementation from `StakedUSDe` if you want to keep this feature or at least allow renouncing non-admin roles.

---
### Lack of zero address check in `acceptAdmin` function
- **Title:** Missing Zero Address Check in `acceptAdmin`
- **Severity:** Low
- **Description:** The `acceptAdmin` function in `SingleAdminAccessControl` allows an address to become admin by calling the function, however there is no check if address is the zero address. The function has an implicit check, because if `msg.sender == _pendingDefaultAdmin` which is set by `transferAdmin`, `_pendingDefaultAdmin` will never be the zero address, but it is good to have an explicit check as well.
- **Impact:** While it is not exploitable in its current form, if the `transferAdmin` function is modified to allow the zero address, it could lead to a broken state. It is a best practice to explicitly check for the zero address.
- **Location:** SingleAdminAccessControl.sol:23
- **Recommendation:** Add a zero-address check in the `acceptAdmin` function to ensure the new admin is not the zero address.

---

### Lack of zero address check for `token` in `rescueTokens` function
- **Title:** Missing Zero Address Check in `rescueTokens`
- **Severity:** Low
- **Description:** The `rescueTokens` function in `StakedUSDe` allows the admin to rescue tokens accidentally sent to the contract. However, there is no check to prevent the rescue of tokens that have a zero address.
- **Impact:** While it is not directly exploitable, it is a good practice to ensure that a zero address is never passed as the token address to avoid unintended consequences.
- **Location:** StakedUSDe.sol:140
- **Recommendation:** Add a zero address check for the `token` parameter in the `rescueTokens` function.

---
### Missing `_checkMinShares` call in `redistributeLockedAmount` function
- **Title:** Missing `_checkMinShares` Check in `redistributeLockedAmount`
- **Severity:** Low
- **Description:** The `redistributeLockedAmount` function does not call the `_checkMinShares` function after burning shares from the `from` address and minting them to the `to` address (or adding to the vesting amount). This creates an inconsistency in the contract's invariant, which requires the total supply to always be zero or greater than or equal to `MIN_SHARES`.
- **Impact:** If the `redistributeLockedAmount` function is used to move shares from one user to another, and the `from` user has a balance of shares that will result in the total supply being less than the `MIN_SHARES`, it will break the contract's invariant and cause `deposit` and `withdraw` operations to revert.
- **Location:** StakedUSDe.sol:165
- **Recommendation:** Add a call to `_checkMinShares()` after burning the tokens in `redistributeLockedAmount` to maintain the contract's invariant.

---
### Unnecessary explicit `override` in `decimals()`
- **Title:** Unnecessary Explicit Override in `decimals()`
- **Severity:** Gas
- **Description:** The `decimals()` function in `StakedUSDe` is explicitly declared with `override(ERC4626, ERC20)`. Because ERC4626 inherits from ERC20, the override is unnecessary. Only override from the base parent contract or sibling contracts.
- **Impact:** Minor gas increase.
- **Location:** StakedUSDe.sol:207
- **Recommendation:** Remove the redundant `override`. The `override` keyword should refer to the base parent contract or sibling contract, not indirectly inherited ones.

---

### Inefficient calculation of `deltaT` in `getUnvestedAmount`
- **Title:** Inefficient Delta Time Calculation
- **Severity:** Gas
- **Description:** The `getUnvestedAmount` function calculates the time difference `deltaT` within an `unchecked` block by subtracting `timeSinceLastDistribution` from `VESTING_PERIOD`. However, the initial check `timeSinceLastDistribution >= VESTING_PERIOD` already ensures that `timeSinceLastDistribution` will not be greater than `VESTING_PERIOD`, making the unchecked block unnecessary.
- **Impact:** Minor gas inefficiency.
- **Location:** StakedUSDe.sol:200
- **Recommendation:** Remove the `unchecked` block and simplify the calculation to `deltaT = VESTING_PERIOD - timeSinceLastDistribution;`.

## Detailed Analysis

### Architecture
The contract has a layered architecture. `SingleAdminAccessControl` provides the basic administrative functionalities. `StakedUSDe` implements the staking logic, inheriting from ERC4626 and adding features like blacklisting and reward distribution. `StakedUSDeV2` extends `StakedUSDe` by adding cooldown mechanisms and delegating funds to `USDeSilo` during the cooldown period.

### Code Quality
The code generally follows good practices with the use of modifiers for access control, `SafeERC20` for token transfers, and clear event emissions. However, there are some inconsistencies in the `renounceRole` implementation and areas where additional validation checks are required. The comments are also not very clear in some areas.

### Centralization Risks
The contract relies heavily on the admin role (DEFAULT_ADMIN_ROLE) for core functionalities. While a single admin is more straightforward to manage, it poses a centralized risk. A compromised admin could potentially cause significant damage to the protocol. The `setCooldownDuration` is particularly concerning.

### Systemic Risks
The contract is dependent on the underlying USDe token and the `USDeSilo` contract. Any vulnerabilities in those contracts may propagate to this staking contract. The contracts also rely on external calls to the underlying USDe token, which need to be considered and properly handled.

### Testing & Verification
The provided code doesn't include test cases. Unit tests are needed to verify that all functionalities including role management, blacklisting, reward distribution, cooldowns, and edge cases are working as expected. It's essential to test all cases including edge cases in the cooldown and redistribution functions.

## Final Recommendations

1.  **Implement a timelock mechanism for `setCooldownDuration` function:** Reduce the centralization risk by requiring a delay before cooldown can be changed. This allows the users a window to exit if a malicious or compromised admin tries to exploit it.
2.  **Fix the logic of `redistributeLockedAmount` function:** Ensure that tokens are properly burned and the vesting amount calculation is correct. The logic of zero address should be more clear.
3.  **Refine `_updateVestingAmount` logic:** Consider allowing distribution of new rewards even if a small amount from previous reward distribution remains.
4.  **Clarify the behavior of `renounceRole`:** Determine the intended behavior and remove the overriding function in `StakedUSDe` or add logic that allows renouncing for non admin roles.
5.  **Add zero address checks in `acceptAdmin` and `rescueTokens` functions:** Implement explicit checks to prevent potential issues.
6.  **Add `_checkMinShares()` call:** Call this function after any burning and minting in `redistributeLockedAmount` to maintain the contract's invariant.
7.  **Remove unnecessary explicit `override` in `decimals()`:** Simplify function declarations.
8. **Optimize the `getUnvestedAmount()` function:** Remove unnecessary unchecked arithmetic.
9.  **Write comprehensive unit tests:** Cover all functionalities including edge cases.
10. **Review and clarify all the comments** to improve the code documentation.

## Improved Code with Security Comments
```solidity
// File: SingleAdminAccessControl.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.19;
/**
 * @title SingleAdminAccessControl
 * @notice SingleAdminAccessControl is a contract that provides a single admin role
 * @notice This contract is a simplified alternative to OpenZeppelin's AccessControlDefaultAdminRules
 */
abstract contract SingleAdminAccessControl is IERC5313, ISingleAdminAccessControl, AccessControl {
  address private _currentDefaultAdmin;
  address private _pendingDefaultAdmin;

  modifier notAdmin(bytes32 role) {
    if (role == DEFAULT_ADMIN_ROLE) revert InvalidAdminChange();
    _;
  }

  /// @notice Transfer the admin role to a new address
  /// @notice This can ONLY be executed by the current admin
  /// @param newAdmin address
  function transferAdmin(address newAdmin) external onlyRole(DEFAULT_ADMIN_ROLE) {
    if (newAdmin == msg.sender) revert InvalidAdminChange();
    _pendingDefaultAdmin = newAdmin;
    emit AdminTransferRequested(_currentDefaultAdmin, newAdmin);
  }

  function acceptAdmin() external {
    // Added explicit zero address check for new admin
    if (msg.sender == address(0)) {
      revert InvalidZeroAddress();
    }
    if (msg.sender != _pendingDefaultAdmin) revert NotPendingAdmin();
    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
  }

  /// @notice grant a role
  /// @notice can only be executed by the current single admin
  /// @notice admin role cannot be granted externally
  /// @param role bytes32
  /// @param account address
  function grantRole(bytes32 role, address account) public override onlyRole(DEFAULT_ADMIN_ROLE) notAdmin(role) {
    _grantRole(role, account);
  }

  /// @notice revoke a role
  /// @notice can only be executed by the current admin
  /// @notice admin role cannot be revoked
  /// @param role bytes32
  /// @param account address
  function revokeRole(bytes32 role, address account) public override onlyRole(DEFAULT_ADMIN_ROLE) notAdmin(role) {
    _revokeRole(role, account);
  }

  /// @notice renounce the role of msg.sender
  /// @notice admin role cannot be renounced
  /// @param role bytes32
  /// @param account address
  function renounceRole(bytes32 role, address account) public virtual override notAdmin(role) {
    super.renounceRole(role, account);
  }

  /**
   * @dev See {IERC5313-owner}.
   */
  function owner() public view virtual returns (address) {
    return _currentDefaultAdmin;
  }

  /**
   * @notice no way to change admin without removing old admin first
   */
  function _grantRole(bytes32 role, address account) internal override {
    if (role == DEFAULT_ADMIN_ROLE) {
      emit AdminTransferred(_currentDefaultAdmin, account);
      _revokeRole(DEFAULT_ADMIN_ROLE, _currentDefaultAdmin);
      _currentDefaultAdmin = account;
      delete _pendingDefaultAdmin;
    }
    super._grantRole(role, account);
  }
}

// File: StakedUSDe.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.19;

/* solhint-disable private-vars-leading-underscore */
/**
 * @title StakedUSDe
 * @notice The StakedUSDe contract allows users to stake USDe tokens and earn a portion of protocol LST and perpetual yield that is allocated
 * to stakers by the Ethena DAO governance voted yield distribution algorithm.  The algorithm seeks to balance the stability of the protocol by funding
 * the protocol's insurance fund, DAO activities, and rewarding stakers with a portion of the protocol's yield.
 */
contract StakedUSDe is SingleAdminAccessControl, ReentrancyGuard, ERC20Permit, ERC4626, IStakedUSDe {
  using SafeERC20 for IERC20;

  /* ------------- CONSTANTS ------------- */
  /// @notice The role that is allowed to distribute rewards to this contract
  bytes32 private constant REWARDER_ROLE = keccak256("REWARDER_ROLE");
  /// @notice The role that is allowed to blacklist and un-blacklist addresses
  bytes32 private constant BLACKLIST_MANAGER_ROLE = keccak256("BLACKLIST_MANAGER_ROLE");
  /// @notice The role which prevents an address to stake
  bytes32 private constant SOFT_RESTRICTED_STAKER_ROLE = keccak256("SOFT_RESTRICTED_STAKER_ROLE");
  /// @notice The role which prevents an address to transfer, stake, or unstake. The owner of the contract can redirect address staking balance if an address is in full restricting mode.
  bytes32 private constant FULL_RESTRICTED_STAKER_ROLE = keccak256("FULL_RESTRICTED_STAKER_ROLE");
  /// @notice The vesting period of lastDistributionAmount over which it increasingly becomes available to stakers
  uint256 private constant VESTING_PERIOD = 8 hours;
  /// @notice Minimum non-zero shares amount to prevent donation attack
  uint256 private constant MIN_SHARES = 1 ether;

  /* ------------- STATE VARIABLES ------------- */

  /// @notice The amount of the last asset distribution from the controller contract into this
  /// contract + any unvested remainder at that time
  uint256 public vestingAmount;

  /// @notice The timestamp of the last asset distribution from the controller contract into this contract
  uint256 public lastDistributionTimestamp;

  /* ------------- MODIFIERS ------------- */

  /// @notice ensure input amount nonzero
  modifier notZero(uint256 amount) {
    if (amount == 0) revert InvalidAmount();
    _;
  }

  /// @notice ensures blacklist target is not owner
  modifier notOwner(address target) {
    if (target == owner()) revert CantBlacklistOwner();
    _;
  }

  /* ------------- CONSTRUCTOR ------------- */

  /**
   * @notice Constructor for StakedUSDe contract.
   * @param _asset The address of the USDe token.
   * @param _initialRewarder The address of the initial rewarder.
   * @param _owner The address of the admin role.
   *
   */
  constructor(IERC20 _asset, address _initialRewarder, address _owner)
    ERC20("Staked USDe", "sUSDe")
    ERC4626(_asset)
    ERC20Permit("sUSDe")
  {
    if (_owner == address(0) || _initialRewarder == address(0) || address(_asset) == address(0)) {
      revert InvalidZeroAddress();
    }

    _grantRole(REWARDER_ROLE, _initialRewarder);
    _grantRole(DEFAULT_ADMIN_ROLE, _owner);
  }

  /* ------------- EXTERNAL ------------- */

  /**
   * @notice Allows the owner to transfer rewards from the controller contract into this contract.
   * @param amount The amount of rewards to transfer.
   */
  function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {
    _updateVestingAmount(amount);
    // transfer assets from rewarder to this contract
    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);

    emit RewardsReceived(amount);
  }

  /**
   * @notice Allows the owner (DEFAULT_ADMIN_ROLE) and blacklist managers to blacklist addresses.
   * @param target The address to blacklist.
   * @param isFullBlacklisting Soft or full blacklisting level.
   */
  function addToBlacklist(address target, bool isFullBlacklisting)
    external
    onlyRole(BLACKLIST_MANAGER_ROLE)
    notOwner(target)
  {
    bytes32 role = isFullBlacklisting ? FULL_RESTRICTED_STAKER_ROLE : SOFT_RESTRICTED_STAKER_ROLE;
    _grantRole(role, target);
  }

  /**
   * @notice Allows the owner (DEFAULT_ADMIN_ROLE) and blacklist managers to un-blacklist addresses.
   * @param target The address to un-blacklist.
   * @param isFullBlacklisting Soft or full blacklisting level.
   */
  function removeFromBlacklist(address target, bool isFullBlacklisting) external onlyRole(BLACKLIST_MANAGER_ROLE) {
    bytes32 role = isFullBlacklisting ? FULL_RESTRICTED_STAKER_ROLE : SOFT_RESTRICTED_STAKER_ROLE;
    _revokeRole(role, target);
  }

  /**
   * @notice Allows the owner to rescue tokens accidentally sent to the contract.
   * Note that the owner cannot rescue USDe tokens because they functionally sit here
   * and belong to stakers but can rescue staked USDe as they should never actually
   * sit in this contract and a staker may well transfer them here by accident.
   * @param token The token to be rescued.
   * @param amount The amount of tokens to be rescued.
   * @param to Where to send rescued tokens
   */
  function rescueTokens(address token, uint256 amount, address to) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {
      // Added zero address check for token
      if (token == address(0)) revert InvalidZeroAddress();
    if (address(token) == asset()) revert InvalidToken();
    IERC20(token).safeTransfer(to, amount);
  }

  /**
   * @dev Burns the full restricted user amount and mints to the desired owner address.
   * @param from The address to burn the entire balance, with the FULL_RESTRICTED_STAKER_ROLE
   * @param to The address to mint the entire balance of "from" parameter.
   */
    function redistributeLockedAmount(address from, address to) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {
        // Check if from address has the full restricted staker role
        if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from)) {
            uint256 amountToDistribute = balanceOf(from);
            uint256 usdeToVest = previewRedeem(amountToDistribute);

            // Burn the entire balance of 'from'
            _burn(from, amountToDistribute);

            // If to is not the zero address, mint the amount to the 'to' address
            if (to != address(0)) {
                // Check if the to address is a full restricted user
                if(hasRole(FULL_RESTRICTED_STAKER_ROLE, to)){
                    revert OperationNotAllowed();
                }
                _mint(to, amountToDistribute);
            }
            else {
              // Add the amount to the vesting amount only if the 'to' address is the zero address
              _updateVestingAmount(usdeToVest);

            }
            _checkMinShares();
            emit LockedAmountRedistributed(from, to, amountToDistribute);

        } else {
            revert OperationNotAllowed();
        }
    }

  /* ------------- PUBLIC ------------- */

  /**
   * @notice Returns the amount of USDe tokens that are vested in the contract.
   */
  function totalAssets() public view override returns (uint256) {
    return IERC20(asset()).balanceOf(address(this)) - getUnvestedAmount();
  }

  /**
   * @notice Returns the amount of USDe tokens that are unvested in the contract.
   */
  function getUnvestedAmount() public view returns (uint256) {
    uint256 timeSinceLastDistribution = block.timestamp - lastDistributionTimestamp;

    if (timeSinceLastDistribution >= VESTING_PERIOD) {
      return 0;
    }

    // Simplified calculation without the unchecked block, because we already checked that
    // timeSinceLastDistribution is not greater than VESTING_PERIOD
    uint256 deltaT = VESTING_PERIOD - timeSinceLastDistribution;

    return (deltaT * vestingAmount) / VESTING_PERIOD;
  }

  /// @dev Necessary because both ERC20 (from ERC20Permit) and ERC4626 declare decimals()
    function decimals() public pure override(ERC4626, ERC20) returns (uint8) {
    return 18;
  }

  /* ------------- INTERNAL ------------- */

  /// @notice ensures a small non-zero amount of shares does not remain, exposing to donation attack
  function _checkMinShares() internal view {
    uint256 _totalSupply = totalSupply();
    if (_totalSupply > 0 && _totalSupply < MIN_SHARES) revert MinSharesViolation();
  }

  /**
   * @dev Deposit/mint common workflow.
   * @param caller sender of assets
   * @param receiver where to send shares
   * @param assets assets to deposit
   * @param shares shares to mint
   */
  function _deposit(address caller, address receiver, uint256 assets, uint256 shares)
    internal
    override
    nonReentrant
    notZero(assets)
    notZero(shares)
  {
    if (hasRole(SOFT_RESTRICTED_STAKER_ROLE, caller) || hasRole(SOFT_RESTRICTED_STAKER_ROLE, receiver)) {
      revert OperationNotAllowed();
    }
    super._deposit(caller, receiver, assets, shares);
    _checkMinShares();
  }

  /**
   * @dev Withdraw/redeem common workflow.
   * @param caller tx sender
   * @param receiver where to send assets
   * @param _owner where to burn shares from
   * @param assets asset amount to transfer out
   * @param shares shares to burn
   */
  function _withdraw(address caller, address receiver, address _owner, uint256 assets, uint256 shares)
    internal
    override
    nonReentrant
    notZero(assets)
    notZero(shares)
  {
    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver) || hasRole(FULL_RESTRICTED_STAKER_ROLE, _owner)) {
      revert OperationNotAllowed();
    }

    super._withdraw(caller, receiver, _owner, assets, shares);
    _checkMinShares();
  }

    function _updateVestingAmount(uint256 newVestingAmount) internal {
        // Removed the check to allow new vesting amounts if existing is not yet fully vested, logic can be changed
        vestingAmount = newVestingAmount;
        lastDistributionTimestamp = block.timestamp;
    }

  /**
   * @dev Hook that is called before any transfer of tokens. This includes
   * minting and burning. Disables transfers from or to of addresses with the FULL_RESTRICTED_STAKER_ROLE role.
   */

  function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {
    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && to != address(0)) {
      revert OperationNotAllowed();
    }
    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, to)) {
      revert OperationNotAllowed();
    }
  }

    /**
     * @dev Remove renounce role access from AccessControl, to prevent users to resign roles.
     * Changed to allow renouncing of non admin roles.
     */
    function renounceRole(bytes32 role, address account) public virtual override {
        if (role == DEFAULT_ADMIN_ROLE) {
            revert OperationNotAllowed();
        }
      super.renounceRole(role, account);
    }
}

// File: StakedUSDeV2.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.19;

/* solhint-disable var-name-mixedcase */
/**
 * @title StakedUSDeV2
 * @notice The StakedUSDeV2 contract allows users to stake USDe tokens and earn a portion of protocol LST and perpetual yield that is allocated
 * to stakers by the Ethena DAO governance voted yield distribution algorithm.  The algorithm seeks to balance the stability of the protocol by funding
 * the protocol's insurance fund, DAO activities, and rewarding stakers with a portion of the protocol's yield.
 * @dev If cooldown duration is set to zero, the StakedUSDeV2 behavior changes to follow ERC4626 standard and disables cooldownShares and cooldownAssets methods. If cooldown duration is greater than zero, the ERC4626 withdrawal and redeem functions are disabled, breaking the ERC4626 standard, and enabling the cooldownShares and the cooldownAssets functions.
 */
contract StakedUSDeV2 is IStakedUSDeCooldown, StakedUSDe {
  using SafeERC20 for IERC20;

  mapping(address => UserCooldown) public cooldowns;

  USDeSilo public immutable silo;

  uint24 public constant MAX_COOLDOWN_DURATION = 90 days;

  uint24 public cooldownDuration;

    /// @notice ensure cooldownDuration is zero
    modifier ensureCooldownOff() {
        if (cooldownDuration != 0) revert OperationNotAllowed();
        _;
    }

    /// @notice ensure cooldownDuration is gt 0
    modifier ensureCooldownOn() {
        if (cooldownDuration == 0) revert OperationNotAllowed();
        _;
    }

  /// @notice Constructor for StakedUSDeV2 contract.
  /// @param _asset The address of the USDe token.
  /// @param initialRewarder The address of the initial rewarder.
  /// @param _owner The address of the admin role.
  constructor(IERC20 _asset, address initialRewarder, address _owner) StakedUSDe(_asset, initialRewarder, _owner) {
    silo = new USDeSilo(address(this), address(_asset));
      // Initial cooldown duration is set to the maximum value by default
    cooldownDuration = MAX_COOLDOWN_DURATION;
  }

  /* ------------- EXTERNAL ------------- */

  /**
   * @dev See {IERC4626-withdraw}.
   */
  function withdraw(uint256 assets, address receiver, address _owner)
    public
    virtual
    override
    ensureCooldownOff
    returns (uint256)
  {
    return super.withdraw(assets, receiver, _owner);
  }

  /**
   * @dev See {IERC4626-redeem}.
   */
  function redeem(uint256 shares, address receiver, address _owner)
    public
    virtual
    override
    ensureCooldownOff
    returns (uint256)
  {
    return super.redeem(shares, receiver, _owner);
  }

  /// @notice Claim the staking amount after the cooldown has finished. The address can only retire the full amount of assets.
  /// @dev unstake can be called after cooldown have been set to 0, to let accounts to be able to claim remaining assets locked at Silo
  /// @param receiver Address to send the assets by the staker
  function unstake(address receiver) external {
    UserCooldown storage userCooldown = cooldowns[msg.sender];
    uint256 assets = userCooldown.underlyingAmount;

    if (block.timestamp >= userCooldown.cooldownEnd || cooldownDuration == 0) {
      userCooldown.cooldownEnd = 0;
      userCooldown.underlyingAmount = 0;

      silo.withdraw(receiver, assets);
    } else {
      revert InvalidCooldown();
    }
  }

  /// @notice redeem assets and starts a cooldown to claim the converted underlying asset
  /// @param assets assets to redeem
  function cooldownAssets(uint256 assets) external ensureCooldownOn returns (uint256 shares) {
    if (assets > maxWithdraw(msg.sender)) revert ExcessiveWithdrawAmount();

    shares = previewWithdraw(assets);

    cooldowns[msg.sender].cooldownEnd = uint104(block.timestamp) + cooldownDuration;
    cooldowns[msg.sender].underlyingAmount += uint152(assets);

    _withdraw(msg.sender, address(silo), msg.sender, assets, shares);
  }

  /// @notice redeem shares into assets and starts a cooldown to claim the converted underlying asset
  /// @param shares shares to redeem
  function cooldownShares(uint256 shares) external ensureCooldownOn returns (uint256 assets) {
    if (shares > maxRedeem(msg.sender)) revert ExcessiveRedeemAmount();

    assets = previewRedeem(shares);

    cooldowns[msg.sender].cooldownEnd = uint104(block.timestamp) + cooldownDuration;
    cooldowns[msg.sender].underlyingAmount += uint152(assets);

    _withdraw(msg.sender, address(silo), msg.sender, assets, shares);
  }

    /// @notice Set cooldown duration. If cooldown duration is set to zero, the StakedUSDeV2 behavior changes to follow ERC4626 standard and disables cooldownShares and cooldownAssets methods. If cooldown duration is greater than zero, the ERC4626 withdrawal and redeem functions are disabled, breaking the ERC4626 standard, and enabling the cooldownShares and the cooldownAssets functions.
    /// @param duration Duration of the cooldown
    function setCooldownDuration(uint24 duration) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (duration > MAX_COOLDOWN_DURATION) {
            revert InvalidCooldown();
        }

        uint24 previousDuration = cooldownDuration;
        cooldownDuration = duration;
        emit CooldownDurationUpdated(previousDuration, cooldownDuration);
    }

  // Added a new function to explicitly disable the cooldown and enable full ERC4626 compliance
  function disableCooldown() external onlyRole(DEFAULT_ADMIN_ROLE) {
        uint24 previousDuration = cooldownDuration;
        cooldownDuration = 0;
        emit CooldownDurationUpdated(previousDuration, cooldownDuration);
    }
}

// File: USDeSilo.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.0;

/* solhint-disable var-name-mixedcase  */
/**
 * @title USDeSilo
 * @notice The Silo allows to store USDe during the stake cooldown process.
 */
contract USDeSilo is IUSDeSiloDefinitions {
  address immutable