# Generated by [Mush Audit](https://mush-audit.vercel.app/)


## 关于

`StakedUSDeV2` 合约是一个质押合约，允许用户质押 USDe 代币并赚取一部分协议收益。它继承自 `StakedUSDe`，后者实现了基于 ERC4626 标准的基本质押功能，并包括单管理员访问控制。`StakedUSDeV2` 引入了取消质押的冷静期，允许合约在用户完全提取其质押的 USDe 之前管理收益分配。它还有一个 `USDeSilo` 合约，用于在冷静期内存储 USDe。该合约为奖励者、黑名单管理者、软限制质押者和完全限制质押者定义了角色，并具有适当的访问控制。它还处理代币救援和锁定资金的重新分配。

## 发现的严重性分类

- 严重 (Critical)：可能导致资金损失或合约完全被攻破的问题
- 高 (High)：可能导致合约故障或中等风险的问题
- 中 (Medium)：可能导致意外行为的问题
- 低 (Low)：违反最佳实践和代码改进
- 气体 (Gas)：优化以减少 gas 消耗

## 发现

### 未受保护的 `setCooldownDuration` 函数可能导致 DoS 或破坏 ERC4626 合规性。
- **标题：** 未受保护的 `setCooldownDuration` 函数
- **严重性：** 高
- **描述：** `setCooldownDuration` 函数仅受 `onlyRole(DEFAULT_ADMIN_ROLE)` 保护，该角色可以由单个管理员账户管理。此函数允许管理员设置任意 `cooldownDuration` 值，最大为 `MAX_COOLDOWN_DURATION`。如果设置为零，`StakedUSDeV2` 将恢复为 ERC4626 标准行为，当大于零时则会破坏它。尽管这是预期的功能，但它构成了一个风险，因为恶意管理员可以随时开启和关闭此功能，这会导致 ERC4626 合规性被破坏，并可能导致拒绝服务攻击。
- **影响：** 恶意或受损的管理员可以将 `cooldownDuration` 设置为一个极高的值，有效地锁定用户资金并阻止他们提取资产。此外，不断地开启和关闭冷却期会破坏 ERC4626 的合规性。
- **位置：** StakedUSDeV2.sol:138
- **建议：** 考虑为更改冷却时间实施时间锁机制，尤其是在合同设置为不启用冷却时间时完全符合 ERC4626 的情况下。这将减少单个管理员的权力，并为用户提供在冷却时间被恶意设置时退出的窗口。此外，考虑添加一个额外的函数，明确禁用冷却时间并将功能设置为完全的 ERC4626。

---
### `redistributeLockedAmount` 函数可能导致资金损失
- **标题：** `redistributeLockedAmount` 函数逻辑错误
- **严重性：** 高
- **描述：** `redistributeLockedAmount` 函数旨在将资产从完全受限制的用户转移到另一个地址或归入 vesting 金额，但缺乏适当的验证，并可能导致资金损失。该函数检查 `hasRole(FULL_RESTRICTED_STAKER_ROLE, from)`，然后使用 `balanceOf(from)` 来计算要转移的金额。恶意用户可以通过不同的机制（例如，直接将代币转移到此合约）来操纵 `balanceOf`，从而绕过当前实现的燃烧机制，并且不添加到 `vestingAmount` 中。如果 `to == address(0)`，其预期逻辑也非常不清楚。当前，如果 `to` 地址为 address(0)，则该金额仅添加到 vesting 金额中，而不是按照当前注释和预期行为进行燃烧。
- **影响：** 恶意行为者或受损的所有者可能会利用此函数来燃烧代币，而不将它们添加到 vesting 金额中，从而在用户余额和实际资产之间造成差异，或窃取用户资金。
- **位置：** StakedUSDe.sol:165
- **建议：**  `redistributeLockedAmount` 函数应准确反映其预期目的，并避免恶意用户操纵代币。燃烧函数应使用 `from` 地址燃烧金额。如果 `to` 地址为零地址，则该函数不得铸造代币。预期功能也应在注释中更清楚地说明。

---

### `_updateVestingAmount` 函数中的检查不足
- **标题：** 检查不足的 Vesting
- **严重性：** 中
- **描述：** 如果 `getUnvestedAmount() > 0`，则 `_updateVestingAmount` 函数会恢复，这意味着在之前的奖励分配中仍有 vesting 期间未完成的情况下，无法转移新的奖励。这会导致一种情况，如果仍有少量金额未归属，则无法分配任何奖励。
- **影响：** 如果仍有少量金额需要领取，则该协议可能会在整个 vesting 期间停止奖励分配。
- **位置：** StakedUSDe.sol:313
- **建议：** 考虑即使剩余少量 vesting 金额，也允许奖励分配。考虑更改此逻辑。如果 `_updateVestingAmount` 的逻辑发生变化，则可能有更好的方法来处理 vesting。

---
### `renounceRole` 函数的功能不明确
- **标题：** 不一致的 `renounceRole` 函数行为
- **严重性：** 中
- **描述：** `renounceRole` 函数在 `StakedUSDe` 中被覆盖，始终以 `OperationNotAllowed()` 恢复，从而有效地禁用所有角色的角色放弃，包括非管理员角色。这与 `SingleAdminAccessControl` 中的实现相矛盾，在 `SingleAdminAccessControl` 中，`renounceRole` 旨在允许用户放弃其角色。 `StakedUSDe` 中的注释表明，这可以防止用户辞职，但是它阻止了所有角色的功能。
- **影响：** 这可能会破坏预期的行为，并降低未来实现中合约的可组合性和灵活性。用户将永远无法放弃任何角色。
- **位置：** StakedUSDe.sol:345
- **建议：** 审查设计选择并确定这是否是预期的行为。如果要保留此功能，请考虑从 `StakedUSDe` 中删除覆盖实现，或者至少允许放弃非管理员角色。

---
### `acceptAdmin` 函数中缺少零地址检查
- **标题：** `acceptAdmin` 中缺少零地址检查
- **严重性：** 低
- **描述：** `SingleAdminAccessControl` 中的 `acceptAdmin` 函数允许一个地址通过调用该函数成为管理员，但是没有检查该地址是否为零地址。该函数具有隐式检查，因为如果 `msg.sender == _pendingDefaultAdmin`（由 `transferAdmin` 设置），则 `_pendingDefaultAdmin` 永远不会是零地址，但是最好也进行显式检查。
- **影响：** 尽管它以当前形式不可利用，但是如果 `transferAdmin` 函数被修改为允许零地址，则可能会导致状态损坏。显式检查零地址是一种最佳实践。
- **位置：** SingleAdminAccessControl.sol:23
- **建议：** 在 `acceptAdmin` 函数中添加零地址检查，以确保新管理员不是零地址。

---

### `rescueTokens` 函数中缺少 `token` 的零地址检查
- **标题：** `rescueTokens` 中缺少零地址检查
- **严重性：** 低
- **描述：** `StakedUSDe` 中的 `rescueTokens` 函数允许管理员抢救意外发送到合约的代币。但是，没有检查以防止抢救零地址的代币。
- **影响：** 尽管它不是直接可利用的，但最好确保永远不要将零地址作为代币地址传递，以避免意外的后果。
- **位置：** StakedUSDe.sol:140
- **建议：** 在 `rescueTokens` 函数中为 `token` 参数添加零地址检查。

---
### `redistributeLockedAmount` 函数中缺少 `_checkMinShares` 调用
- **标题：** `redistributeLockedAmount` 中缺少 `_checkMinShares` 检查
- **严重性：** 低
- **描述：** `redistributeLockedAmount` 函数在从 `from` 地址燃烧份额并将其铸造到 `to` 地址（或添加到 vesting 金额）后，不调用 `_checkMinShares` 函数。这在合约的不变量中创建了一个不一致性，该不变量要求总供应量始终为零或大于或等于 `MIN_SHARES`。
- **影响：** 如果 `redistributeLockedAmount` 函数用于将份额从一个用户移动到另一个用户，并且 `from` 用户拥有的份额余额将导致总供应量小于 `MIN_SHARES`，则它将破坏合约的不变量并导致 `deposit` 和 `withdraw` 操作恢复。
- **位置：** StakedUSDe.sol:165
- **建议：** 在 `redistributeLockedAmount` 中燃烧代币后添加对 `_checkMinShares()` 的调用，以维护合约的不变量。

---
### `decimals()` 中不必要的显式 `override`
- **标题：** `decimals()` 中不必要的显式覆盖
- **严重性：** Gas
- **描述：** `StakedUSDe` 中的 `decimals()` 函数使用 `override(ERC4626, ERC20)` 显式声明。由于 ERC4626 继承自 ERC20，因此覆盖是不必要的。仅覆盖基础父合约或同级合约。
- **影响：** 轻微的 gas 增加。
- **位置：** StakedUSDe.sol:207
- **建议：** 删除冗余的 `override`。 `override` 关键字应引用基础父合约或同级合约，而不是间接继承的合约。

---

### `getUnvestedAmount` 中 `deltaT` 的计算效率低下
- **标题：** 低效的 Delta 时间计算
- **严重性：** Gas
- **描述：** `getUnvestedAmount` 函数通过在 `unchecked` 块中从 `VESTING_PERIOD` 减去 `timeSinceLastDistribution` 来计算时间差 `deltaT`。但是，初始检查 `timeSinceLastDistribution >= VESTING_PERIOD` 已经确保 `timeSinceLastDistribution` 不会大于 `VESTING_PERIOD`，从而使未检查的块成为不必要的。
- **影响：** 轻微的 gas 效率低下。
- **位置：** StakedUSDe.sol:200
- **建议：** 删除 `unchecked` 块并将计算简化为 `deltaT = VESTING_PERIOD - timeSinceLastDistribution;`。

## 详细分析

### 架构
该合约采用分层架构。 `SingleAdminAccessControl` 提供基本的管理功能。 `StakedUSDe` 实现了质押逻辑，继承自 ERC4626 并添加了诸如黑名单和奖励分配之类的功能。 `StakedUSDeV2` 通过添加冷静期机制并在冷静期内将资金委托给 `USDeSilo` 来扩展 `StakedUSDe`。

### 代码质量
该代码通常遵循良好的实践，使用修饰符进行访问控制，使用 `SafeERC20` 进行代币转移，并明确发出事件。但是，`renounceRole` 的实现存在一些不一致之处，并且在某些区域需要额外的验证检查。注释在某些方面也不是很清楚。

### 中心化风险
该合约严重依赖管理员角色 (DEFAULT_ADMIN_ROLE) 来实现核心功能。虽然单个管理员更容易管理，但它构成了集中风险。受损的管理员可能会对协议造成重大损害。 `setCooldownDuration` 尤其令人担忧。

### 系统性风险
该合约依赖于底层 USDe 代币和 `USDeSilo` 合约。这些合约中的任何漏洞都可能会传播到此质押合约。这些合约还依赖于对底层 USDe 代币的外部调用，需要考虑并正确处理。

### 测试与验证
提供的代码不包含测试用例。需要单元测试来验证包括角色管理、黑名单、奖励分配、冷静期和边缘情况在内的所有功能是否按预期工作。必须测试所有情况，包括冷静期和重新分配功能中的边缘情况。

## 最终建议

1.  **为 `setCooldownDuration` 函数实施时间锁机制：** 通过要求在冷却时间更改之前有延迟来降低集中风险。如果恶意或受损的管理员试图利用它，这会为用户提供退出的窗口。
2.  **修复 `redistributeLockedAmount` 函数的逻辑：** 确保代币被正确燃烧，并且 vesting 金额计算正确。零地址的逻辑应更清晰。
3.  **改进 `_updateVestingAmount` 逻辑：** 考虑即使剩余少量之前奖励分配的金额，也允许分配新的奖励。
4.  **澄清 `renounceRole` 的行为：** 确定预期行为并删除 `StakedUSDe` 中的覆盖函数，或添加允许放弃非管理员角色的逻辑。
5.  **在 `acceptAdmin` 和 `rescueTokens` 函数中添加零地址检查：** 实施显式检查以防止潜在问题。
6.  **添加 `_checkMinShares()` 调用：** 在 `redistributeLockedAmount` 中进行任何燃烧和铸造后调用此函数，以维护合约的不变量。
7.  **删除 `decimals()` 中不必要的显式 `override`：** 简化函数声明。
8. **优化 `getUnvestedAmount()` 函数：** 删除不必要的未检查算术。
9.  **编写全面的单元测试：** 涵盖包括边缘情况在内的所有功能。
10. **审查并澄清所有注释**以改进代码文档。

## 改进的带有安全注释的代码
```solidity
// File: SingleAdminAccessControl.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.19;
/**
 * @title SingleAdminAccessControl
 * @notice SingleAdminAccessControl is a contract that provides a single admin role
 * @notice This contract is a simplified alternative to OpenZeppelin's AccessControlDefaultAdminRules
 */
abstract contract SingleAdminAccessControl is IERC5313, ISingleAdminAccessControl, AccessControl {
  address private _currentDefaultAdmin;
  address private _pendingDefaultAdmin;

  modifier notAdmin(bytes32 role) {
    if (role == DEFAULT_ADMIN_ROLE) revert InvalidAdminChange();
    _;
  }

  /// @notice Transfer the admin role to a new address
  /// @notice This can ONLY be executed by the current admin
  /// @param newAdmin address
  function transferAdmin(address newAdmin) external onlyRole(DEFAULT_ADMIN_ROLE) {
    if (newAdmin == msg.sender) revert InvalidAdminChange();
    _pendingDefaultAdmin = newAdmin;
    emit AdminTransferRequested(_currentDefaultAdmin, newAdmin);
  }

  function acceptAdmin() external {
    // 添加了对新管理员的显式零地址检查
    if (msg.sender == address(0)) {
      revert InvalidZeroAddress();
    }
    if (msg.sender != _pendingDefaultAdmin) revert NotPendingAdmin();
    _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
  }

  /// @notice grant a role
  /// @notice can only be executed by the current single admin
  /// @notice admin role cannot be granted externally
  /// @param role bytes32
  /// @param account address
  function grantRole(bytes32 role, address account) public override onlyRole(DEFAULT_ADMIN_ROLE) notAdmin(role) {
    _grantRole(role, account);
  }

  /// @notice revoke a role
  /// @notice can only be executed by the current admin
  /// @notice admin role cannot be revoked
  /// @param role bytes32
  /// @param account address
  function revokeRole(bytes32 role, address account) public override onlyRole(DEFAULT_ADMIN_ROLE) notAdmin(role) {
    _revokeRole(role, account);
  }

  /// @notice renounce the role of msg.sender
  /// @notice admin role cannot be renounced
  /// @param role bytes32
  /// @param account address
  function renounceRole(bytes32 role, address account) public virtual override notAdmin(role) {
    super.renounceRole(role, account);
  }

  /**
   * @dev See {IERC5313-owner}.
   */
  function owner() public view virtual returns (address) {
    return _currentDefaultAdmin;
  }

  /**
   * @notice no way to change admin without removing old admin first
   */
  function _grantRole(bytes32 role, address account) internal override {
    if (role == DEFAULT_ADMIN_ROLE) {
      emit AdminTransferred(_currentDefaultAdmin, account);
      _revokeRole(DEFAULT_ADMIN_ROLE, _currentDefaultAdmin);
      _currentDefaultAdmin = account;
      delete _pendingDefaultAdmin;
    }
    super._grantRole(role, account);
  }
}

// File: StakedUSDe.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.19;

/* solhint-disable private-vars-leading-underscore */
/**
 * @title StakedUSDe
 * @notice The StakedUSDe contract allows users to stake USDe tokens and earn a portion of protocol LST and perpetual yield that is allocated
 * to stakers by the Ethena DAO governance voted yield distribution algorithm.  The algorithm seeks to balance the stability of the protocol by funding
 * the protocol's insurance fund, DAO activities, and rewarding stakers with a portion of the protocol's yield.
 */
contract StakedUSDe is SingleAdminAccessControl, ReentrancyGuard, ERC20Permit, ERC4626, IStakedUSDe {
  using SafeERC20 for IERC20;

  /* ------------- CONSTANTS ------------- */
  /// @notice The role that is allowed to distribute rewards to this contract
  bytes32 private constant REWARDER_ROLE = keccak256("REWARDER_ROLE");
  /// @notice The role that is allowed to blacklist and un-blacklist addresses
  bytes32 private constant BLACKLIST_MANAGER_ROLE = keccak256("BLACKLIST_MANAGER_ROLE");
  /// @notice The role which prevents an address to stake
  bytes32 private constant SOFT_RESTRICTED_STAKER_ROLE = keccak256("SOFT_RESTRICTED_STAKER_ROLE");
  /// @notice The role which prevents an address to transfer, stake, or unstake. The owner of the contract can redirect address staking balance if an address is in full restricting mode.
  bytes32 private constant FULL_RESTRICTED_STAKER_ROLE = keccak256("FULL_RESTRICTED_STAKER_ROLE");
  /// @notice The vesting period of lastDistributionAmount over which it increasingly becomes available to stakers
  uint256 private constant VESTING_PERIOD = 8 hours;
  /// @notice Minimum non-zero shares amount to prevent donation attack
  uint256 private constant MIN_SHARES = 1 ether;

  /* ------------- STATE VARIABLES ------------- */

  /// @notice The amount of the last asset distribution from the controller contract into this
  /// contract + any unvested remainder at that time
  uint256 public vestingAmount;

  /// @notice The timestamp of the last asset distribution from the controller contract into this contract
  uint256 public lastDistributionTimestamp;

  /* ------------- MODIFIERS ------------- */

  /// @notice ensure input amount nonzero
  modifier notZero(uint256 amount) {
    if (amount == 0) revert InvalidAmount();
    _;
  }

  /// @notice ensures blacklist target is not owner
  modifier notOwner(address target) {
    if (target == owner()) revert CantBlacklistOwner();
    _;
  }

  /* ------------- CONSTRUCTOR ------------- */

  /**
   * @notice Constructor for StakedUSDe contract.
   * @param _asset The address of the USDe token.
   * @param _initialRewarder The address of the initial rewarder.
   * @param _owner The address of the admin role.
   *
   */
  constructor(IERC20 _asset, address _initialRewarder, address _owner)
    ERC20("Staked USDe", "sUSDe")
    ERC4626(_asset)
    ERC20Permit("sUSDe")
  {
    if (_owner == address(0) || _initialRewarder == address(0) || address(_asset) == address(0)) {
      revert InvalidZeroAddress();
    }

    _grantRole(REWARDER_ROLE, _initialRewarder);
    _grantRole(DEFAULT_ADMIN_ROLE, _owner);
  }

  /* ------------- EXTERNAL ------------- */

  /**
   * @notice Allows the owner to transfer rewards from the controller contract into this contract.
   * @param amount The amount of rewards to transfer.
   */
  function transferInRewards(uint256 amount) external nonReentrant onlyRole(REWARDER_ROLE) notZero(amount) {
    _updateVestingAmount(amount);
    // transfer assets from rewarder to this contract
    IERC20(asset()).safeTransferFrom(msg.sender, address(this), amount);

    emit RewardsReceived(amount);
  }

  /**
   * @notice Allows the owner (DEFAULT_ADMIN_ROLE) and blacklist managers to blacklist addresses.
   * @param target The address to blacklist.
   * @param isFullBlacklisting Soft or full blacklisting level.
   */
  function addToBlacklist(address target, bool isFullBlacklisting)
    external
    onlyRole(BLACKLIST_MANAGER_ROLE)
    notOwner(target)
  {
    bytes32 role = isFullBlacklisting ? FULL_RESTRICTED_STAKER_ROLE : SOFT_RESTRICTED_STAKER_ROLE;
    _grantRole(role, target);
  }

  /**
   * @notice Allows the owner (DEFAULT_ADMIN_ROLE) and blacklist managers to un-blacklist addresses.
   * @param target The address to un-blacklist.
   * @param isFullBlacklisting Soft or full blacklisting level.
   */
  function removeFromBlacklist(address target, bool isFullBlacklisting) external onlyRole(BLACKLIST_MANAGER_ROLE) {
    bytes32 role = isFullBlacklisting ? FULL_RESTRICTED_STAKER_ROLE : SOFT_RESTRICTED_STAKER_ROLE;
    _revokeRole(role, target);
  }

  /**
   * @notice Allows the owner to rescue tokens accidentally sent to the contract.
   * Note that the owner cannot rescue USDe tokens because they functionally sit here
   * and belong to stakers but can rescue staked USDe as they should never actually
   * sit in this contract and a staker may well transfer them here by accident.
   * @param token The token to be rescued.
   * @param amount The amount of tokens to be rescued.
   * @param to Where to send rescued tokens
   */
  function rescueTokens(address token, uint256 amount, address to) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {
    // 为代币添加零地址检查
    if (token == address(0)) revert InvalidZeroAddress();
    if (address(token) == asset()) revert InvalidToken();
    IERC20(token).safeTransfer(to, amount);
  }

  /**
   * @dev Burns the full restricted user amount and mints to the desired owner address.
   * @param from The address to burn the entire balance, with the FULL_RESTRICTED_STAKER_ROLE
   * @param to The address to mint the entire balance of "from" parameter.
   */
    function redistributeLockedAmount(address from, address to) external nonReentrant onlyRole(DEFAULT_ADMIN_ROLE) {
        // 检查 from 地址是否具有完全受限的质押者角色
        if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from)) {
            uint256 amountToDistribute = balanceOf(from);
            uint256 usdeToVest = previewRedeem(amountToDistribute);

            // 燃烧 “from” 的全部余额
            _burn(from, amountToDistribute);

            // 如果 to 不是零地址，则将金额铸造到 “to” 地址
            if (to != address(0)) {
                // 检查 to 地址是否为完全受限制的用户
                if(hasRole(FULL_RESTRICTED_STAKER_ROLE, to)){
                    revert OperationNotAllowed();
                }
                _mint(to, amountToDistribute);
            }
            else {
              // 仅当 “to” 地址为零地址时，才将金额添加到 vesting 金额
              _updateVestingAmount(usdeToVest);
            }
            _checkMinShares();
            emit LockedAmountRedistributed(from, to, amountToDistribute);

        } else {
            revert OperationNotAllowed();
        }
    }

  /* ------------- PUBLIC ------------- */

  /**
   * @notice Returns the amount of USDe tokens that are vested in the contract.
   */
  function totalAssets() public view override returns (uint256) {
    return IERC20(asset()).balanceOf(address(this)) - getUnvestedAmount();
  }

  /**
   * @notice Returns the amount of USDe tokens that are unvested in the contract.
   */
  function getUnvestedAmount() public view returns (uint256) {
    uint256 timeSinceLastDistribution = block.timestamp - lastDistributionTimestamp;

    if (timeSinceLastDistribution >= VESTING_PERIOD) {
      return 0;
    }

      // 简化计算，无需未检查的块，因为我们已经检查了
      // timeSinceLastDistribution 不大于 VESTING_PERIOD
    uint256 deltaT = VESTING_PERIOD - timeSinceLastDistribution;

    return (deltaT * vestingAmount) / VESTING_PERIOD;
  }

  /// @dev Necessary because both ERC20 (from ERC20Permit) and ERC4626 declare decimals()
    function decimals() public pure override(ERC4626, ERC20) returns (uint8) {
    return 18;
  }

  /* ------------- INTERNAL ------------- */

  /// @notice ensures a small non-zero amount of shares does not remain, exposing to donation attack
  function _checkMinShares() internal view {
    uint256 _totalSupply = totalSupply();
    if (_totalSupply > 0 && _totalSupply < MIN_SHARES) revert MinSharesViolation();
  }

  /**
   * @dev Deposit/mint common workflow.
   * @param caller sender of assets
   * @param receiver where to send shares
   * @param assets assets to deposit
   * @param shares shares to mint
   */
  function _deposit(address caller, address receiver, uint256 assets, uint256 shares)
    internal
    override
    nonReentrant
    notZero(assets)
    notZero(shares)
  {
    if (hasRole(SOFT_RESTRICTED_STAKER_ROLE, caller) || hasRole(SOFT_RESTRICTED_STAKER_ROLE, receiver)) {
      revert OperationNotAllowed();
    }
    super._deposit(caller, receiver, assets, shares);
    _checkMinShares();
  }

  /**
   * @dev Withdraw/redeem common workflow.
   * @param caller tx sender
   * @param receiver where to send assets
   * @param _owner where to burn shares from
   * @param assets asset amount to transfer out
   * @param shares shares to burn
   */
  function _withdraw(address caller, address receiver, address _owner, uint256 assets, uint256 shares)
    internal
    override
    nonReentrant
    notZero(assets)
    notZero(shares)
  {
    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, caller) || hasRole(FULL_RESTRICTED_STAKER_ROLE, receiver) || hasRole(FULL_RESTRICTED_STAKER_ROLE, _owner)) {
      revert OperationNotAllowed();
    }

    super._withdraw(caller, receiver, _owner, assets, shares);
    _checkMinShares();
  }

    function _updateVestingAmount(uint256 newVestingAmount) internal {
        // 删除了检查以允许在现有金额尚未完全 vesting 时新的 vesting 金额，逻辑可以更改
        vestingAmount = newVestingAmount;
        lastDistributionTimestamp = block.timestamp;
    }

  /**
   * @dev Hook that is called before any transfer of tokens. This includes
   * minting and burning. Disables transfers from or to of addresses with the FULL_RESTRICTED_STAKER_ROLE role.
   */

  function _beforeTokenTransfer(address from, address to, uint256) internal virtual override {
    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, from) && to != address(0)) {
      revert OperationNotAllowed();
    }
    if (hasRole(FULL_RESTRICTED_STAKER_ROLE, to)) {
      revert OperationNotAllowed();
    }
  }

    /**
     * @dev Remove renounce role access from AccessControl, to prevent users to resign roles.
     *  更改为允许放弃非管理员角色。
     */
    function renounceRole(bytes32 role, address account) public virtual override {
        if (role == DEFAULT_ADMIN_ROLE) {
            revert OperationNotAllowed();
        }
      super.renounceRole(role, account);
    }
}

// File: StakedUSDeV2.sol
// SPDX-License-Identifier: GPL-3.0
pragma solidity 0.8.19;

/* solhint-disable var-name-mixedcase */
/**
 * @title StakedUSDeV2
 * @notice The StakedUSDeV2 contract allows users to stake USDe tokens and earn a portion of protocol LST and perpetual yield that is allocated
 * to stakers by the Ethena DAO governance voted yield distribution algorithm.  The algorithm seeks to balance the stability of the protocol by funding
 * the protocol's insurance fund, DAO activities, and rewarding stakers with a portion of the protocol's yield.
 * @dev If cooldown duration is set to zero, the StakedUSDeV2 behavior changes to follow ERC4626 standard and disables cooldownShares and cooldownAssets methods. If cooldown duration is greater than zero, the ERC4626 withdrawal and redeem functions are disabled, breaking the ERC4626 standard, and enabling the cooldownShares and the cooldownAssets functions.
 */
contract StakedUSDeV2 is IStakedUSDeCooldown, StakedUSDe {
  using SafeERC20 for IERC20;

  mapping(address => UserCooldown) public cooldowns;

  USDeSilo public immutable silo;

  uint24 public constant MAX_COOLDOWN_DURATION = 90 days;

  uint24 public cooldownDuration;

    /// @notice ensure cooldownDuration is zero
    modifier ensureCooldownOff() {
        if (cooldownDuration != 0) revert OperationNotAllowed();
        _;
    }

    /// @notice ensure cooldownDuration is gt 0
    modifier ensureCooldownOn() {
        if (cooldownDuration == 0) revert OperationNotAllowed();
        _;
    }

  /// @notice Constructor for StakedUSDeV2 contract.
  /// @param _asset The address of the USDe token.
  /// @param initialRewarder The address of the initial rewarder.
  /// @param _owner The address of the admin role.
  constructor(IERC20 _asset, address initialRewarder, address _owner) StakedUSDe(_asset, initialRewarder, _owner) {
    silo = new USDeSilo(address(this), address(_asset));
      // 默认将初始冷却时间设置为最大值
    cooldownDuration = MAX_COOLDOWN_DURATION;
  }

  /* ------------- EXTERNAL ------------- */

  /**
   * @dev See {IERC4626-withdraw}.
   */
  function withdraw(uint256 assets, address receiver, address _owner)
    public
    virtual
    override
    ensureCooldownOff
    returns (uint256)
  {
    return super.withdraw(assets, receiver, _owner);
  }

  /**
   * @dev See {IERC4626-redeem}.
   */
  function redeem(uint256 shares, address receiver, address _owner)
    public
    virtual
    override
    ensureCooldownOff
    returns (uint256)
  {
    return super.redeem(shares, receiver, _owner);
  }

  /// @notice Claim the staking amount after the cooldown has finished. The address can only retire the full amount of assets.
  /// @dev unstake can be called after cooldown have been set to 0, to let accounts to be able to claim remaining assets locked at Silo
  /// @param receiver Address to send the assets by the staker
  function unstake(address receiver) external {
    UserCooldown storage userCooldown = cooldowns[msg.sender];
    uint256 assets = userCooldown.underlyingAmount;

    if (block.timestamp >= userCooldown.cooldownEnd || cooldownDuration == 0) {
      userCooldown.cooldownEnd = 0;
      userCooldown.underlyingAmount = 0;

      silo.withdraw(receiver, assets);
    } else {
      revert InvalidCooldown();
    }
  }

  /// @notice redeem assets and starts a cooldown to claim the converted underlying asset
  /// @param assets assets to redeem
  function cooldownAssets(uint256 assets) external ensureCooldownOn returns (uint256 shares) {
    if (assets > maxWithdraw(msg.sender)) revert ExcessiveWithdrawAmount();

    shares = previewWithdraw(assets);

    cooldowns[msg.sender].cooldownEnd = uint104(block.timestamp) + cooldownDuration;
    cooldowns[msg.sender].underlyingAmount += uint152(assets);

    _withdraw(msg.sender, address(silo), msg.sender, assets, shares);
  }

  /// @notice redeem shares into assets and starts a cooldown to claim the converted underlying asset
  /// @param shares shares to redeem
  function cooldownShares(uint256 shares) external ensureCooldownOn returns (uint256 assets) {
    if (shares > maxRedeem(msg.sender)) revert ExcessiveRedeemAmount();

    assets = previewRedeem(shares);

    cooldowns[msg.sender].cooldownEnd = uint104(block.timestamp) + cooldownDuration;
    cooldowns[msg.sender].underlyingAmount += uint152(assets);

    _withdraw(msg.sender, address(silo), msg.sender, assets, shares);
  }

    /// @notice Set cooldown duration. If cooldown duration is set to zero, the StakedUSDeV2 behavior changes to follow ERC4626 standard and disables cooldownShares and cooldownAssets methods. If cooldown duration is greater than zero, the ERC4626 withdrawal and redeem functions are disabled, breaking the ERC4626 standard, and enabling the cooldownShares and the cooldownAssets functions.
    /// @param duration Duration of the cooldown
    function setCooldownDuration(uint24 duration) external onlyRole(DEFAULT_ADMIN_ROLE) {
        if (duration > MAX_COOLDOWN_DURATION) {
            revert InvalidCooldown();
        }

        uint24 previousDuration = cooldownDuration;
        cooldownDuration = duration;
        emit CooldownDurationUpdated(previousDuration, cooldownDuration);
    }

  // 添加了一个新函数以明确禁用冷静期并启用完整的 ERC4626 合规性
  function disableCooldown() external onlyRole(DEFAULT_ADMIN_
